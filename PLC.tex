\startenvironment PLC

\startluacode

local lpeg = require "lpeg"
intel8080 = {}

intel8080.langdef = {}

intel8080.langdef.opcodes = {
    NOP  = {
        {cmd = 0x00, args = {}},
    },
    LXI  = {
        { cmd = 0x01, args = {{register_pair = "B"},  {word = "data"}}, },
        { cmd = 0x11, args = {{register_pair = "D"},  {word = "data"}}, },
        { cmd = 0x21, args = {{register_pair = "H"},  {word = "data"}}, },
        { cmd = 0x31, args = {{register_pair = "SP"}, {word = "data"}}, },
    },
    STAX = {
        { cmd = 0x02, args = {{register_pair = "B"}}, },
        { cmd = 0x12, args = {{register_pair = "D"}}, },
    },
    INX  = {
        { cmd = 0x03, args = {{register_pair = "B"}}, },
        { cmd = 0x13, args = {{register_pair = "D"}}, },
        { cmd = 0x23, args = {{register_pair = "H"}}, },
        { cmd = 0x33, args = {{register_pair = "SP"}}, },
    },
    INR  = {
        { cmd = 0x04, args = {{register = "B"}}, },
        { cmd = 0x14, args = {{register = "D"}}, },
        { cmd = 0x24, args = {{register = "H"}}, },
        { cmd = 0x34, args = {{register = "M"}}, },
        { cmd = 0x0C, args = {{register = "C"}}, },
        { cmd = 0x1C, args = {{register = "E"}}, },
        { cmd = 0x2C, args = {{register = "L"}}, },
        { cmd = 0x3C, args = {{register = "A"}}, },
    },
    DCR  = {
        { cmd = 0x05, args = {{register = "B"}}, },
        { cmd = 0x15, args = {{register = "D"}}, },
        { cmd = 0x25, args = {{register = "H"}}, },
        { cmd = 0x35, args = {{register = "M"}}, },
        { cmd = 0x0D, args = {{register = "C"}}, },
        { cmd = 0x1D, args = {{register = "E"}}, },
        { cmd = 0x2D, args = {{register = "L"}}, },
        { cmd = 0x3D, args = {{register = "A"}}, },
    },
    MVI  = {
        { cmd = 0x06, args = {{register = "B"}, {byte = "data"}}, },
        { cmd = 0x16, args = {{register = "D"}, {byte = "data"}}, },
        { cmd = 0x26, args = {{register = "H"}, {byte = "data"}}, },
        { cmd = 0x36, args = {{register = "M"}, {byte = "data"}}, },
        { cmd = 0x0E, args = {{register = "C"}, {byte = "data"}}, },
        { cmd = 0x1E, args = {{register = "E"}, {byte = "data"}}, },
        { cmd = 0x2E, args = {{register = "L"}, {byte = "data"}}, },
        { cmd = 0x3E, args = {{register = "A"}, {byte = "data"}}, },
    },
    RLC  = {
        { cmd = 0x07, args = {}, },
    },
    DAD  = {
        { cmd = 0x09, args = {{register_pair = "B"}}, },
        { cmd = 0x19, args = {{register_pair = "D"}}, },
        { cmd = 0x29, args = {{register_pair = "H"}}, },
        { cmd = 0x39, args = {{register_pair = "SP"}}, },
    },
    LDAX = {
        { cmd = 0x0A, args = {{register_pair = "B"}}, },
        { cmd = 0x1A, args = {{register_pair = "D"}}, },
    },
    DCX  = {
        { cmd = 0x0B, args = {{register_pair = "B"}}, },
        { cmd = 0x1B, args = {{register_pair = "D"}}, },
        { cmd = 0x2B, args = {{register_pair = "H"}}, },
        { cmd = 0x3B, args = {{register_pair = "SP"}}, },
    },
    RRC  = {
        { cmd = 0x0F, args = {}, },
    },
    RAL  = {
        { cmd = 0x17, args = {}, },
    },
    RAR  = {
        { cmd = 0x1F, args = {}, },
    },
    SHLD = {
        { cmd = 0x22, args = {{word = "address"}}, },
    },
    DAA  = {
        { cmd = 0x27, args = {}, },
        cmd = 0x27,
    },
    CMA  = {
        { cmd = 0x2F, args = {}, },
        cmd = 0x2F,
    },
    STA  = {
        { cmd = 0x32, args = {{word = "address"}}, },
    },
    STC  = {
        { cmd = 0x37, args = {}, },
    },
    LDA  = {
        { cmd = 0x3A, args = {{word = "address"}}, },
    },
    CMC  = {
        { cmd = 0x3F, args = {}, },
    },
    MOV  = {
        { cmd = 0x40, args = {{register = "B"}, {register = "B"}}, },
        { cmd = 0x41, args = {{register = "B"}, {register = "C"}}, },
        { cmd = 0x42, args = {{register = "B"}, {register = "D"}}, },
        { cmd = 0x43, args = {{register = "B"}, {register = "E"}}, },
        { cmd = 0x44, args = {{register = "B"}, {register = "H"}}, },
        { cmd = 0x45, args = {{register = "B"}, {register = "L"}}, },
        { cmd = 0x46, args = {{register = "B"}, {register = "M"}}, },
        { cmd = 0x47, args = {{register = "B"}, {register = "A"}}, },
        { cmd = 0x48, args = {{register = "C"}, {register = "B"}}, },
        { cmd = 0x49, args = {{register = "C"}, {register = "C"}}, },
        { cmd = 0x4A, args = {{register = "C"}, {register = "D"}}, },
        { cmd = 0x4B, args = {{register = "C"}, {register = "E"}}, },
        { cmd = 0x4C, args = {{register = "C"}, {register = "H"}}, },
        { cmd = 0x4D, args = {{register = "C"}, {register = "L"}}, },
        { cmd = 0x4E, args = {{register = "C"}, {register = "M"}}, },
        { cmd = 0x4F, args = {{register = "C"}, {register = "A"}}, },
        { cmd = 0x50, args = {{register = "D"}, {register = "B"}}, },
        { cmd = 0x51, args = {{register = "D"}, {register = "C"}}, },
        { cmd = 0x52, args = {{register = "D"}, {register = "D"}}, },
        { cmd = 0x53, args = {{register = "D"}, {register = "E"}}, },
        { cmd = 0x54, args = {{register = "D"}, {register = "H"}}, },
        { cmd = 0x55, args = {{register = "D"}, {register = "L"}}, },
        { cmd = 0x56, args = {{register = "D"}, {register = "M"}}, },
        { cmd = 0x57, args = {{register = "D"}, {register = "A"}}, },
        { cmd = 0x58, args = {{register = "E"}, {register = "B"}}, },
        { cmd = 0x59, args = {{register = "E"}, {register = "C"}}, },
        { cmd = 0x5A, args = {{register = "E"}, {register = "D"}}, },
        { cmd = 0x5B, args = {{register = "E"}, {register = "E"}}, },
        { cmd = 0x5C, args = {{register = "E"}, {register = "H"}}, },
        { cmd = 0x5D, args = {{register = "E"}, {register = "L"}}, },
        { cmd = 0x5E, args = {{register = "E"}, {register = "M"}}, },
        { cmd = 0x5F, args = {{register = "E"}, {register = "A"}}, },
        { cmd = 0x60, args = {{register = "H"}, {register = "B"}}, },
        { cmd = 0x61, args = {{register = "H"}, {register = "C"}}, },
        { cmd = 0x62, args = {{register = "H"}, {register = "D"}}, },
        { cmd = 0x63, args = {{register = "H"}, {register = "E"}}, },
        { cmd = 0x64, args = {{register = "H"}, {register = "H"}}, },
        { cmd = 0x65, args = {{register = "H"}, {register = "L"}}, },
        { cmd = 0x66, args = {{register = "H"}, {register = "M"}}, },
        { cmd = 0x67, args = {{register = "H"}, {register = "A"}}, },
        { cmd = 0x68, args = {{register = "L"}, {register = "B"}}, },
        { cmd = 0x69, args = {{register = "L"}, {register = "C"}}, },
        { cmd = 0x6A, args = {{register = "L"}, {register = "D"}}, },
        { cmd = 0x6B, args = {{register = "L"}, {register = "E"}}, },
        { cmd = 0x6C, args = {{register = "L"}, {register = "H"}}, },
        { cmd = 0x6D, args = {{register = "L"}, {register = "L"}}, },
        { cmd = 0x6E, args = {{register = "L"}, {register = "M"}}, },
        { cmd = 0x6F, args = {{register = "L"}, {register = "A"}}, },
        { cmd = 0x70, args = {{register = "M"}, {register = "B"}}, },
        { cmd = 0x71, args = {{register = "M"}, {register = "C"}}, },
        { cmd = 0x72, args = {{register = "M"}, {register = "D"}}, },
        { cmd = 0x73, args = {{register = "M"}, {register = "E"}}, },
        { cmd = 0x74, args = {{register = "M"}, {register = "H"}}, },
        { cmd = 0x75, args = {{register = "M"}, {register = "L"}}, },
        { cmd = 0x77, args = {{register = "M"}, {register = "A"}}, },
        { cmd = 0x78, args = {{register = "A"}, {register = "B"}}, },
        { cmd = 0x79, args = {{register = "A"}, {register = "C"}}, },
        { cmd = 0x7A, args = {{register = "A"}, {register = "D"}}, },
        { cmd = 0x7B, args = {{register = "A"}, {register = "E"}}, },
        { cmd = 0x7C, args = {{register = "A"}, {register = "H"}}, },
        { cmd = 0x7D, args = {{register = "A"}, {register = "L"}}, },
        { cmd = 0x7E, args = {{register = "A"}, {register = "M"}}, },
        { cmd = 0x7F, args = {{register = "A"}, {register = "A"}}, },
    },
    HLT  = {
        {cmd = 0x76, args = {}, },
    },
    ADD  = {
        { cmd = 0x80, args = {{register = "B"}}, },
        { cmd = 0x81, args = {{register = "C"}}, },
        { cmd = 0x82, args = {{register = "D"}}, },
        { cmd = 0x83, args = {{register = "E"}}, },
        { cmd = 0x84, args = {{register = "H"}}, },
        { cmd = 0x85, args = {{register = "L"}}, },
        { cmd = 0x86, args = {{register = "M"}}, },
        { cmd = 0x87, args = {{register = "A"}}, },
    },
    ADC  = {
        { cmd = 0x88, args = {{register = "B"}}, },
        { cmd = 0x89, args = {{register = "C"}}, },
        { cmd = 0x8A, args = {{register = "D"}}, },
        { cmd = 0x8B, args = {{register = "E"}}, },
        { cmd = 0x8C, args = {{register = "H"}}, },
        { cmd = 0x8D, args = {{register = "L"}}, },
        { cmd = 0x8E, args = {{register = "M"}}, },
        { cmd = 0x8F, args = {{register = "A"}}, },
    },
    SUB  = {
        { cmd = 0x90, args = {{register = "B"}}, },
        { cmd = 0x91, args = {{register = "C"}}, },
        { cmd = 0x92, args = {{register = "D"}}, },
        { cmd = 0x93, args = {{register = "E"}}, },
        { cmd = 0x94, args = {{register = "H"}}, },
        { cmd = 0x95, args = {{register = "L"}}, },
        { cmd = 0x96, args = {{register = "M"}}, },
        { cmd = 0x97, args = {{register = "A"}}, },
    },
    SBB  = {
        { cmd = 0x98, args = {{register = "B"}}, },
        { cmd = 0x99, args = {{register = "C"}}, },
        { cmd = 0x9A, args = {{register = "D"}}, },
        { cmd = 0x9B, args = {{register = "E"}}, },
        { cmd = 0x9C, args = {{register = "H"}}, },
        { cmd = 0x9D, args = {{register = "L"}}, },
        { cmd = 0x9E, args = {{register = "M"}}, },
        { cmd = 0x9F, args = {{register = "A"}}, },
    },
    ANA  = {
        { cmd = 0xA0, args = {{register = "B"}}, },
        { cmd = 0xA1, args = {{register = "C"}}, },
        { cmd = 0xA2, args = {{register = "D"}}, },
        { cmd = 0xA3, args = {{register = "E"}}, },
        { cmd = 0xA4, args = {{register = "H"}}, },
        { cmd = 0xA5, args = {{register = "L"}}, },
        { cmd = 0xA6, args = {{register = "M"}}, },
        { cmd = 0xA7, args = {{register = "A"}}, },
    },
    XRA  = {
        { cmd = 0xA8, args = {{register = "B"}}, },
        { cmd = 0xA9, args = {{register = "C"}}, },
        { cmd = 0xAA, args = {{register = "D"}}, },
        { cmd = 0xAB, args = {{register = "E"}}, },
        { cmd = 0xAC, args = {{register = "H"}}, },
        { cmd = 0xAD, args = {{register = "L"}}, },
        { cmd = 0xAE, args = {{register = "M"}}, },
        { cmd = 0xAF, args = {{register = "A"}}, },
    },
    ORA  = {
        { cmd = 0xB0, args = {{register = "B"}}, },
        { cmd = 0xB1, args = {{register = "C"}}, },
        { cmd = 0xB2, args = {{register = "D"}}, },
        { cmd = 0xB3, args = {{register = "E"}}, },
        { cmd = 0xB4, args = {{register = "H"}}, },
        { cmd = 0xB5, args = {{register = "L"}}, },
        { cmd = 0xB6, args = {{register = "M"}}, },
        { cmd = 0xB7, args = {{register = "A"}}, },
    },
    CMP  = {
        { cmd = 0xB8, args = {{register = "B"}}, },
        { cmd = 0xB9, args = {{register = "C"}}, },
        { cmd = 0xBA, args = {{register = "D"}}, },
        { cmd = 0xBB, args = {{register = "E"}}, },
        { cmd = 0xBC, args = {{register = "H"}}, },
        { cmd = 0xBD, args = {{register = "L"}}, },
        { cmd = 0xBE, args = {{register = "M"}}, },
        { cmd = 0xBF, args = {{register = "A"}}, },
    },
    RNZ  = {
        { cmd = 0xC0, args = {}, },
    },
    POP  = {
        { cmd = 0xC1, args = {{register_pair = "B"}}, },
        { cmd = 0xD1, args = {{register_pair = "D"}}, },
        { cmd = 0xE1, args = {{register_pair = "H"}}, },
        { cmd = 0xF1, args = {{register_pair = "PSW"}}, },
    },
    JNZ  = {
        { cmd = 0xC2, args = {{word = "address"}}, },
    },
    JMP  = {
        { cmd = 0xC3, args = {{word = "address"}}, },
    },
    CNZ  = {
        { cmd = 0xC4, args = {{word = "address"}}, },
    },
    PUSH = {
        { cmd = 0xC5, args = {{register_pair = "B"}}, },
        { cmd = 0xD5, args = {{register_pair = "D"}}, },
        { cmd = 0xE5, args = {{register_pair = "H"}}, },
        { cmd = 0xF5, args = {{register_pair = "PSW"}}, },
    },
    ADI  = {
        { cmd = 0xC6, args = {{byte = "data"}}, },
    },
    RST  = {
        {
            cmd = {
                [0] = 0xC7,
                [1] = 0xCF,
                [2] = 0xD7,
                [3] = 0xDF,
                [4] = 0xE7,
                [5] = 0xEF,
                [6] = 0xF7,
                [7] = 0xFF,
            },
            args = {{faux = "address"}},
        },
    },
    RZ   = {
        { cmd = 0xC8, args = {}, },
    },
    RET  = {
        { cmd = 0xC9, args = {}, },
    },
    JZ   = {
        { cmd = 0xCA, args = {{word = "address"}}, },
    },
    CZ   = {
        { cmd = 0xCC, args = {{word = "address"}}, },
    },
    CALL = {
        { cmd = 0xCD, args = {{word = "address"}}, },
    },
    ACI  = {
        { cmd = 0xCE, args = {{byte = "data"}}, },
    },
    RNC  = {
        { cmd = 0xD0, args = {}, },
    },
    JNC  = {
        { cmd = 0xD2, args = {{word = "address"}}, },
    },
    OUT  = {
        { cmd = 0xD3, args = {{byte = "address"}}, },
    },
    CNC  = {
        { cmd = 0xD4, args = {{word = "address"}}, },
    },
    SUI  = {
        { cmd = 0xD6, args = {{byte = "data"}}, },
    },
    RC   = {
        { cmd = 0xD8, args = {}, },
    },
    JC   = {
        { cmd = 0xDA, args = {{word = "address"}}, },
    },
    IN   = {
        { cmd = 0xDB, args = {{byte = "address"}}, },
    },
    CC   = {
        { cmd = 0xDC, args = {{word = "address"}}, },
    },
    SBI  = {
        { cmd = 0xDE, args = {{byte = "data"}}, },
    },
    RPO  = {
        { cmd = 0xE0, args = {}, },
    },
    JPO  = {
        { cmd = 0xE2, args = {{word = "address"}}, },
    },
    XTHL = {
        { cmd = 0xE3, args = {}, },
    },
    CPO  = {
        { cmd = 0xE4, args = {{word = "address"}}, },
    },
    ANI  = {
        { cmd = 0xE6, args = {{byte = "data"}}, },
    },
    RPE  = {
        { cmd = 0xE8, args = {}, },
    },
    PCHL = {
        { cmd = 0xE9, args = {}, },
    },
    JPE  = {
        { cmd = 0xEA, args = {{word = "address"}}, },
    },
    XCHG = {
        { cmd = 0xEB, args = {}, },
    },
    CPE  = {
        { cmd = 0xEC, args = {{word = "address"}}, },
    },
    XRI  = {
        { cmd = 0xEE, args = {{byte = "data"}}, },
    },
    RP   = {
        { cmd = 0xF0, args = {}, },
    },
    JP   = {
        { cmd = 0xF2, args = {{word = "address"}}, },
    },
    DI   = {
        { cmd = 0xF3, args = {}, },
    },
    CP   = {
        { cmd = 0xF4, args = {{word = "address"}}, },
    },
    ORI  = {
        { cmd = 0xF6, args = {{byte = "data"}}, },
    },
    RM   = {
        { cmd = 0xF8, args = {}, },
    },
    SPHL = {
        { cmd = 0xF9, args = {}, },
    },
    JM   = {
        { cmd = 0xFA, args = {{word = "address"}}, },
    },
    EI   = {
        { cmd = 0xFB, args = {}, },
    },
    CM   = {
        { cmd = 0xFC, args = {{word = "address"}}, },
    },
    CPI  = {
        { cmd = 0xFE, args = {{byte = "data"}}, },
    },
}

intel8080.parsing = {}

intel8080.parsing.blank = lpeg.S(utf8.char(0x20, 0x09))
intel8080.parsing.arg_sep = lpeg.P ","
intel8080.parsing.label_delim = lpeg.P ":"
intel8080.parsing.comment_delim = lpeg.P ";"
intel8080.parsing.newline = lpeg.P "\n"

intel8080.parsing.register = {
    A = lpeg.Cg((lpeg.P "A" + lpeg.P "a") / string.upper),
    B = lpeg.Cg((lpeg.P "B" + lpeg.P "b") / string.upper),
    C = lpeg.Cg((lpeg.P "C" + lpeg.P "c") / string.upper),
    D = lpeg.Cg((lpeg.P "D" + lpeg.P "d") / string.upper),
    E = lpeg.Cg((lpeg.P "E" + lpeg.P "e") / string.upper),
    H = lpeg.Cg((lpeg.P "H" + lpeg.P "h") / string.upper),
    L = lpeg.Cg((lpeg.P "L" + lpeg.P "l") / string.upper),
    M = lpeg.Cg((lpeg.P "M" + lpeg.P "m") / string.upper),
}

intel8080.parsing.register_pair = {
    B = lpeg.Cg((lpeg.P "B" + lpeg.P "b") / string.upper),
    D = lpeg.Cg((lpeg.P "D" + lpeg.P "d") / string.upper),
    H = lpeg.Cg((lpeg.P "H" + lpeg.P "h") / string.upper),

    SP = lpeg.Cg((lpeg.P "SP" + lpeg.P "sp") / string.upper),
    PC = lpeg.Cg((lpeg.P "PC" + lpeg.P "pc") / string.upper),

    PSW = lpeg.Cg((lpeg.P "PSW" + lpeg.P "psw") / string.upper),
}

intel8080.parsing.numeric = {
    bin = lpeg.Ct(lpeg.Cg(lpeg.R "01"^1, "value")
        * lpeg.Cg(lpeg.S "Bb" / "2", "radix")),

    oct = lpeg.Ct(lpeg.Cg(lpeg.R "07"^1, "value")
        * lpeg.Cg(lpeg.S "OoQq" / "8", "radix")),

    dec = lpeg.Ct(lpeg.Cg(lpeg.R "09"^1, "value")
        * lpeg.Cg(lpeg.S "Dd"^-1 / "10", "radix")),

    hex = lpeg.Ct(lpeg.Cg((lpeg.R "09" + lpeg.R "af" + lpeg.R "AF")^0 / string.upper, "value")
        * lpeg.Cg(lpeg.S "Hh" / "16", "radix")),
}

intel8080.parsing.location_counter = lpeg.Cg (lpeg.P "$")

intel8080.parsing.label
    = lpeg.Cg((lpeg.R("az", "AZ") + lpeg.S "_-" + lpeg.P "@" + lpeg.P "?") * (lpeg.R("az", "AZ", "09") + lpeg.S "_-")^0)

intel8080.parsing.operation = {
    OR    = lpeg.Cg ((lpeg.P "OR" + lpeg.P "or") / string.upper),
    XOR   = lpeg.Cg ((lpeg.P "XOR" + lpeg.P "xor") / string.upper),
    AND   = lpeg.Cg ((lpeg.P "AND" + lpeg.P "and") / string.upper),
    NOT   = lpeg.Cg ((lpeg.P "NOT" + lpeg.P "not") / string.upper),
    EQ    = lpeg.Cg ((lpeg.P "EQ" + lpeg.P "eq") / string.upper),
    LT    = lpeg.Cg ((lpeg.P "LT" + lpeg.P "lt") / string.upper),
    LE    = lpeg.Cg ((lpeg.P "LE" + lpeg.P "le") / string.upper),
    GT    = lpeg.Cg ((lpeg.P "GT" + lpeg.P "gt") / string.upper),
    GE    = lpeg.Cg ((lpeg.P "GE" + lpeg.P "ge") / string.upper),
    NE    = lpeg.Cg ((lpeg.P "NE" + lpeg.P "ne") / string.upper),
    MOD   = lpeg.Cg ((lpeg.P "MOD" + lpeg.P "mod") / string.upper),
    SHL   = lpeg.Cg ((lpeg.P "SHL" + lpeg.P "shl") / string.upper),
    SHR   = lpeg.Cg ((lpeg.P "SHR" + lpeg.P "shr") / string.upper),
    HIGH  = lpeg.Cg ((lpeg.P "HIGH" + lpeg.P "high") / string.upper),
    LOW   = lpeg.Cg ((lpeg.P "LOW" + lpeg.P "low") / string.upper),
    PLUS  = lpeg.Cg (lpeg.P "+"),
    MINUS = lpeg.Cg (lpeg.P "-"),
    TIMES = lpeg.Cg (lpeg.P "*"),
    DIV   = lpeg.Cg (lpeg.P "/"),
}

intel8080.parsing.expression = {}

intel8080.parsing.expression.flatten = function (expr)
    if type(expr) == "table" and #expr == 1 then
        expr = expr[1]
    end
    return expr
end

intel8080.parsing.expression.collect = function (expr)
    if not expr[1] then return expr end

    expr.binary_operations = {}
    expr.operands = {}

    for key, value in ipairs(expr) do
        if value.binary_operation then
            table.insert(expr.binary_operations, value.binary_operation)
        else
            table.insert(expr.operands, value)
        end
        expr[key] = nil
    end

    return expr
end

intel8080.parsing.expression.rule =
    lpeg.P {
        [1] = "expression",
        expression = lpeg.Ct(
            lpeg.Cg(lpeg.V "disjunct")
            * (
                intel8080.parsing.blank^1
                * lpeg.Ct(lpeg.V "disjunction")
                * intel8080.parsing.blank^1
                * lpeg.Cg(lpeg.V "disjunct")
            )^0
        ) / intel8080.parsing.expression.flatten / intel8080.parsing.expression.collect,

        disjunct = lpeg.Ct(
            lpeg.Cg(lpeg.V "conjuct")
            * (
                intel8080.parsing.blank^1
                * lpeg.Ct(lpeg.V "conjunction")
                * intel8080.parsing.blank^1
                * lpeg.Cg(lpeg.V "conjuct")
            )^0
        ) / intel8080.parsing.expression.flatten / intel8080.parsing.expression.collect,

        conjuct = lpeg.Ct(
            lpeg.Cg(lpeg.V "comparison_operand")
            * (
                intel8080.parsing.blank^1
                * lpeg.Ct(lpeg.V "comparison")
                * intel8080.parsing.blank^1
                * lpeg.Cg(lpeg.V "comparison_operand")
            )^0
        ) / intel8080.parsing.expression.flatten / intel8080.parsing.expression.collect,

        comparison_operand = lpeg.Ct(
            lpeg.Cg(lpeg.V "factor")
            * (
                intel8080.parsing.blank^0
                * lpeg.Ct(lpeg.V "addition")
                * intel8080.parsing.blank^0
                * lpeg.Cg(lpeg.V "factor")
            )^0
        ) / intel8080.parsing.expression.flatten / intel8080.parsing.expression.collect,

        factor = lpeg.Ct(
            lpeg.Cg(lpeg.V "value")
            * (
                (
                    intel8080.parsing.blank^0
                    * lpeg.Ct(lpeg.V "multiplication_symbol")
                    * intel8080.parsing.blank^0
                    * lpeg.Cg(lpeg.V "value")
                )
                +
                (
                    intel8080.parsing.blank^1
                    * lpeg.Ct(lpeg.V "multiplication_name")
                    * intel8080.parsing.blank^1
                    * lpeg.Cg(lpeg.V "value")
                )
            )^0
        ) / intel8080.parsing.expression.flatten / intel8080.parsing.expression.collect,

        value = lpeg.Ct(
            lpeg.Cg(
                lpeg.Ct(
                    (
                        (
                            lpeg.V "unary_operation_symbol"
                            * intel8080.parsing.blank^0
                        )
                        +
                        (
                            lpeg.V "unary_operation_name"
                            * intel8080.parsing.blank^1
                        )
                    )^0
                )
                , "unary_operations"
            )
            * (
                lpeg.V "number"
                + lpeg.V "loc_counter"
                + lpeg.V "asm_label"
                + (
                    lpeg.P "("
                    * intel8080.parsing.blank^0
                    * lpeg.Cg(lpeg.V "expression", "expression")
                    * intel8080.parsing.blank^0
                    * lpeg.P ")"
                )
            )
        ),

        disjunction = lpeg.Cg(intel8080.parsing.operation.OR + intel8080.parsing.operation.XOR, "binary_operation"),
        conjunction = lpeg.Cg(intel8080.parsing.operation.AND, "binary_operation"),
        unary_operation_name = lpeg.Cg(
            intel8080.parsing.operation.NOT
            + intel8080.parsing.operation.HIGH
            + intel8080.parsing.operation.LOW
        ),
        unary_operation_symbol = lpeg.Cg(
            intel8080.parsing.operation.MINUS
        ),
        comparison = lpeg.Cg(
            intel8080.parsing.operation.EQ
            + intel8080.parsing.operation.LT
            + intel8080.parsing.operation.LE
            + intel8080.parsing.operation.GT
            + intel8080.parsing.operation.GE
            + intel8080.parsing.operation.NE
            , "binary_operation"
        ),
        addition = lpeg.Cg(intel8080.parsing.operation.PLUS + intel8080.parsing.operation.MINUS, "binary_operation"),
        multiplication_symbol = lpeg.Cg(intel8080.parsing.operation.TIMES + intel8080.parsing.operation.DIV, "binary_operation"),
        multiplication_name = lpeg.Cg(intel8080.parsing.operation.MOD + intel8080.parsing.operation.SHL + intel8080.parsing.operation.SHR, "binary_operation"),
        number = lpeg.Cg(
            intel8080.parsing.numeric.hex
            + intel8080.parsing.numeric.oct
            + intel8080.parsing.numeric.bin
            + intel8080.parsing.numeric.dec
            , "numeric"
        ),
        loc_counter = lpeg.Cg(intel8080.parsing.location_counter, "location_counter"),
        asm_label = lpeg.Cg(intel8080.parsing.label, "label"),
    }

local generate_cmds = function (instructions)
    local final_result = nil

    for name, contents in pairs(instructions) do
        local cmd_name = lpeg.Cg(
            (lpeg.P(string.upper(name)) + lpeg.P(string.lower(name))) / string.upper
            , "cmd_name"
        )

        for _, variation_contents in ipairs(contents) do
            local next_cmd = cmd_name
            local arg_list = nil
            local byte_count = 1

            for _, arg_contents in ipairs(variation_contents.args) do
                local next_arg = nil

                if arg_contents.register then
                    next_arg = lpeg.Cg(intel8080.parsing.register[arg_contents.register], "register")
                    next_arg = lpeg.Ct(next_arg)
                elseif arg_contents.register_pair then
                    next_arg = lpeg.Cg(intel8080.parsing.register_pair[arg_contents.register_pair], "register_pair")
                    next_arg = lpeg.Ct(next_arg)
                elseif arg_contents.byte then
                    next_arg = lpeg.Cg(intel8080.parsing.expression.rule, "byte")
                    next_arg = lpeg.Ct(next_arg)
                    byte_count = byte_count + 1
                elseif arg_contents.word then
                    next_arg = lpeg.Cg(intel8080.parsing.expression.rule, "word")
                    next_arg = lpeg.Ct(next_arg)
                    byte_count = byte_count + 2
                elseif arg_contents.faux then
                    next_arg = lpeg.Cg(intel8080.parsing.expression.rule, "faux")
                    next_arg = lpeg.Ct(next_arg)
                end

                if arg_list == nil then
                    arg_list = lpeg.Cg(next_arg)
                else
                    arg_list = arg_list * intel8080.parsing.blank^0 * intel8080.parsing.arg_sep * intel8080.parsing.blank^0 * lpeg.Cg(next_arg)
                end
            end

            if arg_list then
                arg_list = lpeg.Cg(lpeg.Ct(arg_list), "args")
                next_cmd = lpeg.Ct(
                    next_cmd * intel8080.parsing.blank^1 * arg_list
                )
            else
                next_cmd = lpeg.Ct(next_cmd)
            end

            next_cmd = next_cmd
                / function (full_cmd)
                    full_cmd.bytes = {}
                    for i = 1, byte_count do
                        full_cmd.bytes[i] = 0
                    end
                    full_cmd.bytes[1] = variation_contents.cmd
                    return full_cmd
                end

            if final_result == nil then
                final_result = next_cmd
            else
                final_result = final_result + next_cmd
            end
        end
    end

    return final_result
end

intel8080.parsing.cmd = generate_cmds(intel8080.langdef.opcodes)

intel8080.parsing.line = lpeg.P {
    [1] = "line",
    line = lpeg.Ct(
        lpeg.V "label"
        * intel8080.parsing.blank^0
        * intel8080.parsing.label_delim
        * intel8080.parsing.blank^0
        * lpeg.V "cmd"
        * intel8080.parsing.blank^0
        * intel8080.parsing.comment_delim
        * intel8080.parsing.blank^0
        * lpeg.V "comment"
    )
    + lpeg.Ct(
        lpeg.V "cmd"
        * intel8080.parsing.blank^0
        * intel8080.parsing.comment_delim
        * intel8080.parsing.blank^0
        * lpeg.V "comment"
    )
    + lpeg.Ct(
        lpeg.V "label"
        * intel8080.parsing.blank^0
        * intel8080.parsing.label_delim
        * intel8080.parsing.blank^0
        * lpeg.V "cmd"
        * intel8080.parsing.blank^0
    )
    + lpeg.Ct(
        lpeg.V "label"
        * intel8080.parsing.blank^0
        * intel8080.parsing.label_delim
        * intel8080.parsing.blank^0
        * intel8080.parsing.comment_delim
        * intel8080.parsing.blank^0
        * lpeg.V "comment"
    )
    + lpeg.Ct(
        lpeg.V "label"
        * intel8080.parsing.blank^0
        * intel8080.parsing.label_delim
        * intel8080.parsing.blank^0
    )
    + lpeg.Ct(
        lpeg.V "cmd"
        * intel8080.parsing.blank^0
    )
    + lpeg.Ct(
        intel8080.parsing.comment_delim
        * intel8080.parsing.blank^0
        * lpeg.V "comment"
    ),

    label = lpeg.Cg(
        intel8080.parsing.label, "label"
    ),
    cmd = lpeg.Cg(
        intel8080.parsing.cmd, "cmd"
    ),
    comment = lpeg.Cg(
        (lpeg.P(1) - intel8080.parsing.newline)^0, "comment"
    ),
}

intel8080.parsing.listing = lpeg.Ct(
    (intel8080.parsing.blank + intel8080.parsing.newline)^0
    * intel8080.parsing.line
    * (intel8080.parsing.blank + intel8080.parsing.newline)^0
    * (
        (intel8080.parsing.blank + intel8080.parsing.newline)^0
        * intel8080.parsing.line
        * (intel8080.parsing.blank + intel8080.parsing.newline)^0
    )^0
)
* lpeg.P (-1)

intel8080.assembly = {}

intel8080.assembly.to_unsigned_word = function (val)
    return val & 0xFFFF
end

intel8080.assembly.match_to_number = function (num_match)
    return tonumber(num_match.value, num_match.radix)
end

intel8080.assembly.unary_operation = {
    ["-"] = function (rhs)
        return intel8080.assembly.to_unsigned_word(-rhs)
    end,
    ["NOT"] = function (rhs)
        return intel8080.assembly.to_unsigned_word(~rhs)
    end,
    ["HIGH"] = function (rhs)
        return intel8080.assembly.to_unsigned_word((rhs & 0xFF00) >> 8)
    end,
    ["LOW"] = function (rhs)
        return intel8080.assembly.to_unsigned_word(rhs & 0x00FF)
    end,
}

intel8080.assembly.binary_operation = {
    ["+"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            +
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["-"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            -
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["*"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            *
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["/"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            //
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["MOD"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            %
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["SHL"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            <<
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["SHR"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            >>
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["EQ"] = function (lhs, rhs)
        if lhs == rhs then
            return 0xFFFF
        else
            return 0x0000
        end
    end,
    ["NE"] = function (lhs, rhs)
        if lhs ~= rhs then
            return 0xFFFF
        else
            return 0x0000
        end
    end,
    ["LT"] = function (lhs, rhs)
        if lhs < rhs then
            return 0xFFFF
        else
            return 0x0000
        end
    end,
    ["LE"] = function (lhs, rhs)
        if lhs <= rhs then
            return 0xFFFF
        else
            return 0x0000
        end
    end,
    ["GT"] = function (lhs, rhs)
        if lhs > rhs then
            return 0xFFFF
        else
            return 0x0000
        end
    end,
    ["GE"] = function (lhs, rhs)
        if lhs >= rhs then
            return 0xFFFF
        else
            return 0x0000
        end
    end,
    ["AND"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            &
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["OR"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            |
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
    ["XOR"] = function (lhs, rhs)
        return intel8080.assembly.to_unsigned_word(
            intel8080.assembly.to_unsigned_word(lhs)
            ~
            intel8080.assembly.to_unsigned_word(rhs)
        )
    end,
}

intel8080.assembly.evaluate_expression = function (expr, loc_counter, labels)
    local result
    if not (expr.binary_operations and expr.operands) then
        if expr.numeric then
            result = intel8080.assembly.to_unsigned_word(
                intel8080.assembly.match_to_number(expr.numeric)
            )
        end
        if expr.location_counter then
            result = intel8080.assembly.to_unsigned_word(
                loc_counter
            )
        end
        if expr.label then
            result = intel8080.assembly.to_unsigned_word(
                labels[expr.label]
            )
        end
        if expr.ascii then
            result = {utf8.codepoint(expr.ascii, 1, 2)}
            result = intel8080.assembly.to_unsigned_word(
                (result[1] << 8) + result[2]
            )
        end
        if expr.expression then
            result = intel8080.assembly.to_unsigned_word(
                intel8080.assembly.evaluate_expression(expr.expression, loc_counter, labels)
            )
        end

        for i = #expr.unary_operations, 1, -1 do
            result = intel8080.assembly.unary_operation[expr.unary_operations[i]](result)
        end
    else
        result = intel8080.assembly.to_unsigned_word(
            intel8080.assembly.evaluate_expression(expr.operands[1], loc_counter, labels)
        )
        for i = 1, #expr.binary_operations do
            local rhs = intel8080.assembly.evaluate_expression(expr.operands[i + 1], loc_counter, labels)
            result = intel8080.assembly.binary_operation[expr.binary_operations[i]](result, rhs)
        end
    end

    return result
end

intel8080.assembly.assemble = function (code, location_counter, labels)
    location_counter = location_counter or 0x0000
    labels = labels or {}
    local starting_location_counter = location_counter
    code = intel8080.parsing.listing:match(code)

    -- pass 1
    for _, line in ipairs(code) do
        if line.label then
            labels[line.label] = location_counter
        end

        if line.cmd then
            location_counter = location_counter + #line.cmd.bytes
            location_counter = location_counter & 0xFFFF
        end
    end

    location_counter = starting_location_counter
    -- pass 2
    for _, line in ipairs(code) do
        line.location_counter = location_counter

        if line.label then
            labels[line.label] = location_counter
        end

        if line.cmd then
            if line.cmd.args then
                if line.cmd.args[#line.cmd.args].byte then
                    local val = intel8080.assembly.evaluate_expression(line.cmd.args[#line.cmd.args].byte, location_counter, labels)
                    line.cmd.bytes[2] = val & 0x00FF
                elseif line.cmd.args[#line.cmd.args].word then
                    local val = intel8080.assembly.evaluate_expression(line.cmd.args[#line.cmd.args].word, location_counter, labels)
                    line.cmd.bytes[2] = val & 0x00FF
                    line.cmd.bytes[3] = (val & 0xFF00) >> 8
                elseif line.cmd.args[#line.cmd.args].faux then
                    local val = intel8080.assembly.evaluate_expression(line.cmd.args[#line.cmd.args].faux, location_counter, labels)
                    line.cmd.bytes[1] = line.cmd.bytes[1][val]
                    if line.cmd.bytes[1] == nil then
                        error("malformed faux argument to " .. line.cmd.cmd_name)
                    end
                end
            end

            location_counter = location_counter + #line.cmd.bytes
            location_counter = location_counter & 0xFFFF
        end
    end

    return code
end

intel8080.formatting = {}

intel8080.formatting.format_expression = function (expr)
    local result
    if not (expr.binary_operations and expr.operands) then
        result = ""
        for _, op in ipairs(expr.unary_operations) do
            result = result .. op
            if #op ~= 1 then
                result = result .. " "
            end
        end

        if expr.numeric then
            local radix = {["2"] = "B", ["8"] = "O", ["10"] = "", ["16"] = "H"}
            result = result .. expr.numeric.value .. radix[expr.numeric.radix]
        end
        if expr.location_counter then
            result = result .. "$"
        end
        if expr.label then
            result = result .. expr.label
        end
        if expr.ascii then
            result = result .. "'" .. expr.ascii:gsub("''", "'") .. "'"
        end
        if expr.expression then
            result = result .. "(" .. intel8080.formatting.format_expression(expr.expression) .. ")"
        end
    else
        result = intel8080.formatting.format_expression(expr.operands[1])
        for i = 1, #expr.binary_operations do
           result = result .. " " .. expr.binary_operations[i] .. " " .. intel8080.formatting.format_expression(expr.operands[i + 1])
        end
    end

    return result
end

intel8080.formatting.make_text_listing = function (code, location_counter, labels)
    local state = intel8080.assembly.assemble(code, location_counter, labels)
    local formatted_lines = {}
    local last_formatted_line = 0

    for _, line in ipairs(state) do
        if not line.cmd and not line.comment and not line.label then
            goto continue
        end

        if last_formatted_line == 0 or line.location_counter ~= formatted_lines[last_formatted_line].location_counter then
            last_formatted_line = last_formatted_line + 1
            formatted_lines[last_formatted_line] = {
                location_counter = line.location_counter,
                label = {line.label},
                bytes = line.cmd and line.cmd.bytes or {},
                asm = line.cmd and {cmd_name = line.cmd.cmd_name, args = line.cmd.args} or nil,
                comment = {line.comment}
            }
        else
            table.insert(formatted_lines[last_formatted_line].label, line.label)
            table.insert(formatted_lines[last_formatted_line].comment, line.comment)
            formatted_lines[last_formatted_line].asm = line.cmd and {cmd_name = line.cmd.cmd_name, args = line.cmd.args} or nil
            formatted_lines[last_formatted_line].bytes = line.cmd and line.cmd.bytes or nil
        end
        ::continue::
    end

    local final_result = {}

    for line_no, line in ipairs(formatted_lines) do
        local counter = line.location_counter
        local result = {"", "", "", "", ""}

        result[1] = result[1] .. string.format([==[%.4XH]==], counter)

        for i, label in ipairs(line.label) do
            result[2] = result[2] .. string.format([==[%s:]==], label)
        end

        for i, byte in ipairs(line.bytes) do
            result[3] = result[3] .. string.format([==[%.2X]==], byte)
            counter = counter + 1
        end

        local args = ""
        if line.asm.args then
            for i, arg in ipairs(line.asm.args) do
                local formatted
                if arg.register or arg.register_pair then
                    formatted = arg.register or arg.register_pair
                elseif arg.byte or arg.word or arg.faux then
                    formatted = intel8080.formatting.format_expression(arg.byte or arg.word or arg.faux)
                end

                if i == 1 then
                    args = formatted
                else
                    args = args .. ", " .. formatted
                end
            end

            result[4] = string.format([==[%s %s]==], line.asm.cmd_name, args)
        else
            result[4] = string.format([==[%s]==], line.asm.cmd_name)
        end

        for i, comment in ipairs(line.comment) do
            if i == 1 then
                result[5] = string.format([==[%s]==], comment)
            else
                result[5] = string.format([==[ %s]==], comment)
            end
        end

        table.insert(final_result, result)
    end

    local max_label
    local max_bin
    local max_cmd

    for _, line in ipairs(final_result) do
        max_label = math.max(max_label or 0, #(line[2]))
        max_bin = math.max(max_bin or 0, #(line[3]))
        max_cmd = math.max(max_cmd or 0, #(line[4]))
    end

    local bin_space
    if max_label == 0 then
        max_label = ""
        bin_space = ""
    else
        bin_space = "    "
    end
    if max_bin == 0 then
        max_bin = ""
    end
    if max_cmd == 0 then
        max_cmd = ""
    end

    local printout
    for _, result in ipairs(final_result) do
        printout = (printout and printout .. "\n" or "")
            .. result[1]
            .. string.format("    %" .. max_label .. "s", result[2])
            .. bin_space
            .. string.format("%-" .. max_bin .. "s", result[3])
            .. string.format("    %-" .. max_cmd .. "s", result[4])
            .. "    " .. result[5]
    end

    return printout
end

intel8080.formatting.make_listing = function (code, location_counter, labels)
    local state = intel8080.assembly.assemble(code, location_counter, labels)
    local formatted_lines = {}
    local last_formatted_line = 0

    for _, line in ipairs(state) do
        if not line.cmd and not line.comment and not line.label then
            goto continue
        end

        if last_formatted_line == 0 or line.location_counter ~= formatted_lines[last_formatted_line].location_counter then
            last_formatted_line = last_formatted_line + 1
            formatted_lines[last_formatted_line] = {
                location_counter = line.location_counter,
                label = {line.label},
                bytes = line.cmd and line.cmd.bytes or {},
                asm = line.cmd and {cmd_name = line.cmd.cmd_name, args = line.cmd.args} or nil,
                comment = {line.comment}
            }
        else
            table.insert(formatted_lines[last_formatted_line].label, line.label)
            table.insert(formatted_lines[last_formatted_line].comment, line.comment)
            formatted_lines[last_formatted_line].asm = line.cmd and {cmd_name = line.cmd.cmd_name, args = line.cmd.args} or nil
            formatted_lines[last_formatted_line].bytes = line.cmd and line.cmd.bytes or nil
        end
        ::continue::
    end

    context.setupxtable({
        bodyfont = "10pt",
    })
    context.startxtable()

    context.startxtablehead()

    context.startxrow({align = "center, lohi"})
        context.startxcell({option = "fixed", width = "\\dimexpr\\widthofstring{Адрес}"})
            context("Адрес")
        context.stopxcell()

        context.startxcell({option = "fixed"})
            context("Метка")
        context.stopxcell()

        context.startxcell({option = "fixed"})
            context("Машинный\\blank[none] код")
        context.stopxcell()

        context.startxcell({option = "stretch"})
            context("Ассемблерный\\blank[none] код")
        context.stopxcell()

        context.startxcell({option = "stretch"})
            context("Комментарии")
        context.stopxcell()
    context.stopxrow()

    context.stopxtablehead()

    context.startxtablebody()
    for line_no, line in ipairs(formatted_lines) do
        context.startxrow()
            context.startxcell({align = "center"})
                local counter = line.location_counter
                local result
                for i, _ in ipairs(line.bytes) do
                    if i == 1 then
                        result = string.format([==[{\tt %.4XH}]==], counter)
                    else
                        result = result .. string.format([==[\blank[none]{\tt %.4XH}]==], counter)
                    end
                    counter = counter + 1
                end
                context(result)
            context.stopxcell()

            context.startxcell({align = "flushright"})
                local result
                for i, label in ipairs(line.label) do
                    if i == 1 then
                        result = string.format([==[{\tt %s:}]==], label)
                    else
                        result = result .. string.format([==[\blank[none]{\tt %s:}]==], label)
                    end
                end
                context(result)
            context.stopxcell()

            context.startxcell({align = "center", width = "\\dimexpr\\widthofstring{Машинный} + 1em"})
                local result
                for i, byte in ipairs(line.bytes) do
                    if i == 1 then
                        result = string.format([==[{\tt %.2X}]==], byte)
                    else
                        result = result .. string.format([==[\blank[none]{\tt %.2X}]==], byte)
                    end
                    counter = counter + 1
                end
                context(result)
            context.stopxcell()

            context.startxcell({align = "flushleft", width = "\\dimexpr\\widthofstring{Ассемблерный код}"})
                local args = ""
                if line.asm.args then
                    for i, arg in ipairs(line.asm.args) do
                        local formatted
                        if arg.register or arg.register_pair then
                            formatted = arg.register or arg.register_pair
                        elseif arg.byte or arg.word or arg.faux then
                            formatted = intel8080.formatting.format_expression(arg.byte or arg.word or arg.faux)
                        end

                        if i == 1 then
                            args = formatted
                        else
                            args = args .. ", " .. formatted
                        end
                    end

                    context([==[{\tt %s %s}]==], line.asm.cmd_name, args)
                else
                    context([==[{\tt %s}]==], line.asm.cmd_name)
                end
            context.stopxcell()

            context.startxcell({align = "width, stretch, morehyphenated, fullhz, hanging"})
                for i, comment in ipairs(line.comment) do
                    if i == 1 then
                        context([==[%s]==], comment)
                    else
                        context([==[ %s]==], comment)
                    end
                end
            context.stopxcell()
        context.stopxrow()
    end

    context.stopxtablebody()

    context.startxtablefoot()

    context.stopxtablefoot()

    context.stopxtable()
end

\stopluacode

\stopenvironment
